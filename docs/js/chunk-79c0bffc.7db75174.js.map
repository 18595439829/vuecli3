{"version":3,"sources":["webpack:///./node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/ol/geom/LineString.js","webpack:///./node_modules/ol/geom/flat/center.js","webpack:///./node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/ol/geom/MultiPoint.js","webpack:///./node_modules/ol/geom/flat/interpolate.js"],"names":["MultiLineString","SimpleGeometry","coordinates","opt_layout","opt_ends","call","this","ends_","maxDelta_","maxDeltaRevision_","Array","isArray","setCoordinates","undefined","setFlatCoordinates","layout","getLayout","lineStrings","flatCoordinates","ends","i","ii","length","lineString","getFlatCoordinates","push","__proto__","prototype","Object","create","constructor","appendLineString","slice","changed","clone","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getCoordinateAtM","m","opt_extrapolate","opt_interpolate","XYM","XYZM","extrapolate","interpolate","getCoordinates","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","MULTI_LINE_STRING","intersectsExtent","extent","setLayout","LineString","flatMidpoint_","flatMidpointRevision_","appendCoordinate","coordinate","forEachSegment","callback","getCoordinateAt","fraction","opt_dest","getLength","getFlatMidpoint","LINE_STRING","linearRingss","endss","flatCenters","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","orientedRevision_","orientedFlatCoordinates_","polygons","polygon","j","jj","appendPolygon","len","newEndss","getOrientedFlatCoordinates","containsXY","getArea","opt_right","orient","inflate","getEndss","getFlatInteriorPoints","getInteriorPoints","MultiPoint","GeometryLayout","simplifiedEndss","getPolygon","prevEnds","Polygon","getPolygons","GeometryType","MULTI_POLYGON","deflate","lastEnds","appendPoint","point","multiPoint","squaredDistance","getPoint","n","getPoints","points","MULTI_POINT","interpolatePoint","pointX","NaN","pointY","x1","y1","cumulativeLengths","x2","y2","target","t","o","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM"],"mappings":"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","file":"js/chunk-79c0bffc.7db75174.js","sourcesContent":["/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {interpolatePoint, lineStringsCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.clone = function clone () {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != GeometryLayout.XYM &&\n         this.layout != GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinatesArray(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  MultiLineString.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  MultiLineString.prototype.getLineString = function getLineString (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  MultiLineString.prototype.getLineStrings = function getLineStrings () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(\n        flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.getType = function getType () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry));\n\n\nexport default MultiLineString;\n\n//# sourceMappingURL=MultiLineString.js.map","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LineString.prototype.constructor = LineString;\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n  LineString.prototype.clone = function clone () {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n  };\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  LineString.prototype.getLength = function getLength () {\n    return lineStringLength(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.getType = function getType () {\n    return GeometryType.LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n  };\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(SimpleGeometry));\n\n\nexport default LineString;\n\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var extent = createEmpty();\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n\n//# sourceMappingURL=center.js.map","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRingsArray} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */ (coordinates);\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.clone = function clone () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function getArea () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates, 0, this.endss_, this.stride);\n  };\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function getEndss () {\n    return this.endss_;\n  };\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRingsArray(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function getPolygon (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function getPolygons () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.getType = function getType () {\n    return GeometryType.MULTI_POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n        0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n\n  return MultiPolygon;\n}(SimpleGeometry));\n\n\nexport default MultiPolygon;\n\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPoint(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;\n  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  MultiPoint.prototype.appendPoint = function appendPoint (point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.clone = function clone () {\n    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    return multiPoint;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = squaredDx(\n        x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (var j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  MultiPoint.prototype.getPoint = function getPoint (index) {\n    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(this.flatCoordinates.slice(\n      index * this.stride, (index + 1) * this.stride), this.layout);\n  };\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  MultiPoint.prototype.getPoints = function getPoints () {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array<Point>} */\n    var points = [];\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.getType = function getType () {\n    return GeometryType.MULTI_POINT;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return MultiPoint;\n}(SimpleGeometry));\n\n\nexport default MultiPoint;\n\n//# sourceMappingURL=MultiPoint.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map"],"sourceRoot":""}