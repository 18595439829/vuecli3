{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/Tile.js","webpack:///./node_modules/ol/ImageTile.js","webpack:///./node_modules/ol/TileCache.js","webpack:///./node_modules/ol/reproj.js","webpack:///./node_modules/ol/reproj/Triangulation.js","webpack:///./node_modules/ol/reproj/Tile.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/source/Tile.js","webpack:///./node_modules/ol/source/TileEventType.js","webpack:///./node_modules/ol/source/UrlTile.js","webpack:///./node_modules/ol/source/TileImage.js","webpack:///./node_modules/ol/source/XYZ.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/source/OSM.js","webpack:///./node_modules/ol/source/Source.js"],"names":["getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","height","width","maxResolution","max","length","Array","pow","half","DEGREES","getMetersPerUnit","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getTileRangeForExtentAndZ","getFullTileRange","containsXY","EventTarget","Tile","state","call","this","options","interimTile","transition_","transition","transitionStarts_","__proto__","prototype","Object","create","constructor","changed","dispatchEvent","EventType","CHANGE","getInterimTile","tile","getState","TileState","LOADED","refreshInterimChain","prev","LOADING","IDLE","getTileCoord","setState","load","getAlpha","id","time","start","delta","inTransition","endTransition","ImageTile","src","crossOrigin","tileLoadFunction","crossOrigin_","src_","image_","Image","imageListenerKeys_","tileLoadFunction_","disposeInternal","unlistenImage_","getBlankImage","dispose","ABORT","getImage","handleImageError_","ERROR","handleImageLoad_","image","naturalWidth","naturalHeight","EMPTY","LOAD","forEach","ctx","fillStyle","fillRect","canvas","LRUCache","TileCache","opt_highWaterMark","expireCache","usedTiles","canExpireCache","peekLast","zKey","toString","contains","pop","pruneExceptNewestZ","getCount","peekFirstKey","remove","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","isFinite","enlargeClipPoint","centroidX","centroidY","dX","dY","distance","sqrt","round","pixelRatio","targetExtent","triangulation","sources","gutter","opt_renderEdges","context","scale","sourceDataExtent","i","arr","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","u1","v1","u2","v2","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","save","beginPath","p0","p1","p2","moveTo","lineTo","clip","transform","translate","restore","strokeStyle","lineWidth","closePath","stroke","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","maxSourceExtent","errorThreshold","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","addQuad_","leftBound","Infinity","min","newTriangle","minX","maxX","bind","addTriangle_","a","b","aSrc","bSrc","cSrc","push","d","dSrc","maxSubdivision","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","dx","centerSrc","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","opt_errorThreshold","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","sourceProjExtent","getResolution","errorThresholdInPixels","triangulation_","getZForResolution","sourceRange","srcX","srcY","minY","maxY","unlistenSources_","reproject_","size","getTileSize","leftToLoad","sourceListenKey","e","setTimeout","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","replace","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","nullTileUrlFunction","expandUrl","url","urls","match","exec","charCode","startCharCode","charCodeAt","stopCharCode","String","fromCharCode","stop","parseInt","Source","TileSource","attributions","attributionsCollapsible","opaque_","opaque","tilePixelRatio_","tilePixelRatio","tileCache","cacheSize","tmpSize","key_","tileOptions","getTileCacheForProjection","forEachLoadedTile","callback","tileCoordKey","loaded","covered","containsKey","get","getGutterForProjection","setKey","getOpaque","getResolutions","getTile","getTileGrid","getTileGridForProjection","thisProj","getProjection","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","opt_projection","getWrapX","refresh","clear","useTile","TileSourceEvent","Event","type","TILELOADSTART","TILELOADEND","TILELOADERROR","UrlTile","generateTileUrlFunction_","tileUrlFunction","setUrls","setUrl","setTileUrlFunction","tileLoadingKeys_","getTileLoadFunction","getTileUrlFunction","getUrls","handleTileChange","event","uid","tileState","TileEventType","setTileLoadFunction","join","TileImage","defaultTileLoadFunction","tileClass","tileCacheForProjection","tileGridForProjection","reprojectionErrorThreshold_","reprojectionErrorThreshold","renderReprojectionEdges_","usedTileCache","getGutter","projKey","highWaterMark","createTile_","urlTileCoord","tileUrl","sourceProjection","cache","newTile","getTileInternal","set","setRenderReprojectionEdges","render","setTileGridForProjection","tilegrid","proj","imageTile","XYZ","tmpTileCoord","TileGrid","zoomFactor","resolutions_","origins","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","sizes","calculateTileRanges_","forEachTileCoord","zoom","j","jj","forEachTileCoordParentTileRange","opt_this","opt_tileRange","opt_extent","tileCoordExtent","floor","getOrigin","getTileCoordChildTileRange","getTileRangeExtent","resolution","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","adjustX","adjustY","xFromOrigin","yFromOrigin","tileCoordX","tileCoordY","getTileCoordResolution","opt_direction","fullTileRanges","ATTRIBUTION","OSM","BaseObject","projection_","attributions_","adaptAttributions","attributionsCollapsible_","loading","state_","READY","wrapX_","getAttributions","getAttributionsCollapsible","setAttributions","attributionLike","isArray","frameState"],"mappings":"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","file":"js/chunk-88df6142.06d3ce3a.js","sourcesContent":["/**\n * @module ol/tilegrid\n */\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {toSize} from './size.js';\nimport {containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth} from './extent.js';\nimport Corner from './extent/Corner.js';\nimport {get as getProjection, METERS_PER_UNIT} from './proj.js';\nimport Units from './proj/Units.js';\nimport TileGrid from './tilegrid/TileGrid.js';\n\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  var z = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n\n  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize\n  });\n}\n\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\n * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  /** @type {XYZOptions} */\n  var xyzOptions = opt_options || {};\n\n  var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  /** @type {import(\"./tilegrid/TileGrid.js\").Options} */\n  var gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize\n    )\n  };\n  return new TileGrid(gridOptions);\n}\n\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\n  var maxZoom = opt_maxZoom !== undefined ?\n    opt_maxZoom : DEFAULT_MAX_ZOOM;\n\n  var height = getHeight(extent);\n  var width = getWidth(extent);\n\n  var tileSize = toSize(opt_tileSize !== undefined ?\n    opt_tileSize : DEFAULT_TILE_SIZE);\n  var maxResolution = Math.max(\n    width / tileSize[0], height / tileSize[1]);\n\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n  for (var z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  var extent = projection.getExtent();\n  if (!extent) {\n    var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/tilecoord\n */\n\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord=} opt_tileCoord Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {string} Quad key.\n */\nexport function quadKey(tileCoord) {\n  var z = tileCoord[0];\n  var digits = new Array(z);\n  var mask = 1 << (z - 1);\n  var i, charCode;\n  for (i = 0; i < z; ++i) {\n    // 48 is charCode for 0 - '0'.charCodeAt(0)\n    charCode = 48;\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n    digits[i] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n  return digits.join('');\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  var z = tileCoord[0];\n  var x = tileCoord[1];\n  var y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  var extent = tileGrid.getExtent();\n  var tileRange;\n  if (!extent) {\n    tileRange = tileGrid.getFullTileRange(z);\n  } else {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  }\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/Tile\n */\nimport TileState from './TileState.js';\nimport {easeIn} from './easing.js';\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\n\n\n/**\n * A function that takes an {@link module:ol/Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string)} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @api\n */\n\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nvar Tile = /*@__PURE__*/(function (EventTarget) {\n  function Tile(tileCoord, state, opt_options) {\n    EventTarget.call(this);\n\n    var options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {TileState}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ = options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n  }\n\n  if ( EventTarget ) Tile.__proto__ = EventTarget;\n  Tile.prototype = Object.create( EventTarget && EventTarget.prototype );\n  Tile.prototype.constructor = Tile;\n\n  /**\n   * @protected\n   */\n  Tile.prototype.changed = function changed () {\n    this.dispatchEvent(EventType.CHANGE);\n  };\n\n  /**\n   * @return {string} Key.\n   */\n  Tile.prototype.getKey = function getKey () {\n    return this.key + '/' + this.tileCoord;\n  };\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  Tile.prototype.getInterimTile = function getInterimTile () {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    var tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  };\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  Tile.prototype.refreshInterimChain = function refreshInterimChain () {\n    if (!this.interimTile) {\n      return;\n    }\n\n    var tile = this.interimTile;\n    var prev = /** @type {Tile} */ (this);\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  };\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  Tile.prototype.getTileCoord = function getTileCoord () {\n    return this.tileCoord;\n  };\n\n  /**\n   * @return {TileState} State.\n   */\n  Tile.prototype.getState = function getState () {\n    return this.state;\n  };\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {TileState} state State.\n   * @api\n   */\n  Tile.prototype.setState = function setState (state) {\n    this.state = state;\n    this.changed();\n  };\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  Tile.prototype.load = function load () {};\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  Tile.prototype.getAlpha = function getAlpha (id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    var start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    var delta = time - start + (1000 / 60); // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  };\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  Tile.prototype.inTransition = function inTransition (id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  };\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  Tile.prototype.endTransition = function endTransition (id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  };\n\n  return Tile;\n}(EventTarget));\n\n\nexport default Tile;\n\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport EventType from './events/EventType.js';\n\n\nvar ImageTile = /*@__PURE__*/(function (Tile) {\n  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n\n    Tile.call(this, tileCoord, state, opt_options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.imageListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n\n  }\n\n  if ( Tile ) ImageTile.__proto__ = Tile;\n  ImageTile.prototype = Object.create( Tile && Tile.prototype );\n  ImageTile.prototype.constructor = ImageTile;\n\n  /**\n   * @inheritDoc\n   */\n  ImageTile.prototype.disposeInternal = function disposeInternal () {\n    if (this.state == TileState.LOADING) {\n      this.unlistenImage_();\n      this.image_ = getBlankImage();\n    }\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n    this.state = TileState.ABORT;\n    this.changed();\n    Tile.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  ImageTile.prototype.getImage = function getImage () {\n    return this.image_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  ImageTile.prototype.getKey = function getKey () {\n    return this.src_;\n  };\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  ImageTile.prototype.handleImageError_ = function handleImageError_ () {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  };\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {\n    var image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  ImageTile.prototype.load = function load () {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [\n        listenOnce(this.image_, EventType.ERROR,\n          this.handleImageError_, this),\n        listenOnce(this.image_, EventType.LOAD,\n          this.handleImageLoad_, this)\n      ];\n      this.tileLoadFunction_(this, this.src_);\n    }\n  };\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {\n    this.imageListenerKeys_.forEach(unlistenByKey);\n    this.imageListenerKeys_ = null;\n  };\n\n  return ImageTile;\n}(Tile));\n\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  var ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n\n//# sourceMappingURL=ImageTile.js.map","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nvar TileCache = /*@__PURE__*/(function (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n\n    LRUCache.call(this, opt_highWaterMark);\n\n  }\n\n  if ( LRUCache ) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );\n  TileCache.prototype.constructor = TileCache;\n\n  /**\n   * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n   */\n  TileCache.prototype.expireCache = function expireCache (usedTiles) {\n    while (this.canExpireCache()) {\n      var tile = this.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  };\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {\n    if (this.getCount() === 0) {\n      return;\n    }\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function(tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n\n  return TileCache;\n}(LRUCache));\n\n\nexport default TileCache;\n\n//# sourceMappingURL=TileCache.js.map","/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D} from './dom.js';\nimport {containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj,\n  targetCenter, targetResolution) {\n\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n        sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio,\n  sourceResolution, sourceExtent, targetResolution, targetExtent,\n  triangulation, sources, gutter, opt_renderEdges) {\n\n  var context = createCanvasContext2D(Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function(src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(\n    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  var stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function(src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n\n    stitchContext.drawImage(\n      src.image,\n      gutter, gutter,\n      src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n      xPos * stitchScale, yPos * stitchScale,\n      srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  var targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0], y0 = source[0][1];\n    var x1 = source[1][0], y1 = source[1][1];\n    var x2 = source[2][0], y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    var augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n\n    context.transform(\n      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY);\n\n    context.scale(sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio);\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n\n//# sourceMappingURL=reproj.js.map","/**\n * @module ol/reproj/Triangulation\n */\nimport {boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight,\n  getTopLeft, getTopRight, getWidth, intersects} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {getTransform} from '../proj.js';\n\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target\n */\n\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n\n  /**\n   * @type {import(\"../proj/Projection.js\").default}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n\n  /**\n   * @type {import(\"../proj/Projection.js\").default}\n   * @private\n   */\n  this.targetProj_ = targetProj;\n\n  /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n  var transformInvCache = {};\n  var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n   * @private\n   */\n  this.transformInv_ = function(c) {\n    var key = c[0] + '/' + c[1];\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n    return transformInvCache[key];\n  };\n\n  /**\n   * @type {import(\"../extent.js\").Extent}\n   * @private\n   */\n  this.maxSourceExtent_ = maxSourceExtent;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n  /**\n   * @type {Array<Triangle>}\n   * @private\n   */\n  this.triangles_ = [];\n\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n  this.wrapsXInSource_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      (getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent()));\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\n    getWidth(this.sourceProj_.getExtent()) : null;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ?\n    getWidth(this.targetProj_.getExtent()) : null;\n\n  var destinationTopLeft = getTopLeft(targetExtent);\n  var destinationTopRight = getTopRight(targetExtent);\n  var destinationBottomRight = getBottomRight(targetExtent);\n  var destinationBottomLeft = getBottomLeft(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n  this.addQuad_(\n    destinationTopLeft, destinationTopRight,\n    destinationBottomRight, destinationBottomLeft,\n    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\n    MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function(triangle, i, arr) {\n      leftBound = Math.min(leftBound,\n        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    });\n\n    // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n    this.triangles_.forEach(function(triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0],\n        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\n          [triangle.source[1][0], triangle.source[1][1]],\n          [triangle.source[2][0], triangle.source[2][1]]];\n        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        }\n\n        // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n        var minX = Math.min(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }.bind(this));\n  }\n\n  transformInvCache = {};\n};\n\n/**\n * Adds triangle to the triangulation.\n * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n * @private\n */\nTriangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\nTriangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n\n  var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ?\n    getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n  // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n  var wrapsX = this.sourceProj_.canWrapX() &&\n               sourceCoverageX > 0.5 && sourceCoverageX < 1;\n\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = boundingExtent([a, b, c, d]);\n      var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH ||\n        needsSubdivision;\n    }\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH ||\n          needsSubdivision;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n\n      var dx;\n      if (wrapsX) {\n        var centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n             modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX -\n            modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n\n        this.addQuad_(\n          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(\n          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n\n        this.addQuad_(\n          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(\n          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {import(\"../extent.js\").Extent} Calculated extent.\n */\nTriangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {\n  var extent = createEmpty();\n\n  this.triangles_.forEach(function(triangle, i, arr) {\n    var src = triangle.source;\n    extendCoordinate(extent, src[0]);\n    extendCoordinate(extent, src[1]);\n    extendCoordinate(extent, src[2]);\n  });\n\n  return extent;\n};\n\n/**\n * @return {Array<Triangle>} Array of the calculated triangles.\n */\nTriangulation.prototype.getTriangles = function getTriangles () {\n  return this.triangles_;\n};\n\nexport default Triangulation;\n\n//# sourceMappingURL=Triangulation.js.map","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {getArea, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceResolution, render as renderReprojected} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /*@__PURE__*/(function (Tile) {\n  function ReprojTile(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges\n  ) {\n    Tile.call(this, tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ?\n      getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]);\n\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(\n      sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n      opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n      sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(\n          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent, this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  if ( Tile ) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create( Tile && Tile.prototype );\n  ReprojTile.prototype.constructor = ReprojTile;\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.disposeInternal = function disposeInternal () {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    Tile.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function getImage () {\n    return this.canvas_;\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function reproject_ () {\n    var sources = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_,\n        sourceResolution, this.sourceTileGrid_.getExtent(),\n        targetResolution, targetExtent, this.triangulation_, sources,\n        this.gutter_, this.renderEdges_);\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.load = function load () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      var leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          var sourceListenKey = listen(tile, EventType.CHANGE,\n            function(e) {\n              var state = tile.getState();\n              if (state == TileState.LOADED ||\n                    state == TileState.ERROR ||\n                    state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile));\n\n\nexport default ReprojTile;\n\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template.replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, function() {\n            var y = -tileCoord[2] - 1;\n            return y.toString();\n          })\n          .replace(dashYRegEx, function() {\n            var z = tileCoord[0];\n            var range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            var y = range.getHeight() + tileCoord[2];\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        var h = tileCoordHash(tileCoord);\n        var index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  var urls = [];\n  var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    var startCharCode = match[1].charCodeAt(0);\n    var stopCharCode = match[2].charCodeAt(0);\n    var charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    var stop = parseInt(match[2], 10);\n    for (var i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/source/Tile\n */\nimport {abstract} from '../util.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport Event from '../events/Event.js';\nimport {equivalent} from '../proj.js';\nimport {toSize, scale as scaleSize} from '../size.js';\nimport Source from './Source.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {wrapX, getForProjection as getTileGridForProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque]\n * @property {number} [tilePixelRatio]\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n */\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nvar TileSource = /*@__PURE__*/(function (Source) {\n  function TileSource(options) {\n\n    Source.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?\n      options.tilePixelRatio : 1;\n\n    /**\n     * @protected\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {transition: options.transition};\n\n  }\n\n  if ( Source ) TileSource.__proto__ = Source;\n  TileSource.prototype = Object.create( Source && Source.prototype );\n  TileSource.prototype.constructor = TileSource;\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  TileSource.prototype.canExpireCache = function canExpireCache () {\n    return this.tileCache.canExpireCache();\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, import(\"../TileRange.js\").default>} usedTiles Used tiles.\n   */\n  TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    var covered = true;\n    var tile, tileCoordKey, loaded;\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(tileCoordKey));\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = (callback(tile) !== false);\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  TileSource.prototype.getGutterForProjection = function getGutterForProjection (projection) {\n    return 0;\n  };\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  TileSource.prototype.getKey = function getKey () {\n    return this.key_;\n  };\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  TileSource.prototype.setKey = function setKey (key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  TileSource.prototype.getOpaque = function getOpaque (projection) {\n    return this.opaque_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileSource.prototype.getResolutions = function getResolutions () {\n    return this.tileGrid.getResolutions();\n  };\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {\n    return abstract();\n  };\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @api\n   */\n  TileSource.prototype.getTileGrid = function getTileGrid () {\n    return this.tileGrid;\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  };\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {\n    var thisProj = this.getProjection();\n    if (thisProj && !equivalent(thisProj, projection)) {\n      return null;\n    } else {\n      return this.tileCache;\n    }\n  };\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {\n    return this.tilePixelRatio_;\n  };\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  };\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default=} opt_projection Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {\n    var projection = opt_projection !== undefined ?\n      opt_projection : this.getProjection();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileSource.prototype.refresh = function refresh () {\n    this.tileCache.clear();\n    this.changed();\n  };\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  TileSource.prototype.useTile = function useTile (z, x, y, projection) {};\n\n  return TileSource;\n}(Source));\n\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport var TileSourceEvent = /*@__PURE__*/(function (Event) {\n  function TileSourceEvent(type, tile) {\n\n    Event.call(this, type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n\n  }\n\n  if ( Event ) TileSourceEvent.__proto__ = Event;\n  TileSourceEvent.prototype = Object.create( Event && Event.prototype );\n  TileSourceEvent.prototype.constructor = TileSourceEvent;\n\n  return TileSourceEvent;\n}(Event));\n\nexport default TileSource;\n\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror'\n\n};\n\n//# sourceMappingURL=TileEventType.js.map","/**\n * @module ol/source/UrlTile\n */\nimport {getUid} from '../util.js';\nimport TileState from '../TileState.js';\nimport {expandUrl, createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileEventType from './TileEventType.js';\nimport {getKeyZXY} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque]\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction\n * @property {number} [tilePixelRatio]\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction]\n * @property {string} [url]\n * @property {Array<string>} [urls]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n */\n\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nvar UrlTile = /*@__PURE__*/(function (TileSource) {\n  function UrlTile(options) {\n\n    TileSource.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ = !options.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : nullTileUrlFunction;\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    if (options.tileUrlFunction) {\n      this.setTileUrlFunction(options.tileUrlFunction, this.key_);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n  }\n\n  if ( TileSource ) UrlTile.__proto__ = TileSource;\n  UrlTile.prototype = Object.create( TileSource && TileSource.prototype );\n  UrlTile.prototype.constructor = UrlTile;\n\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {\n    return this.tileLoadFunction;\n  };\n\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {\n    return this.tileUrlFunction;\n  };\n\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  UrlTile.prototype.getUrls = function getUrls () {\n    return this.urls;\n  };\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  UrlTile.prototype.handleTileChange = function handleTileChange (event) {\n    var tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    var uid = getUid(tile);\n    var tileState = tile.getState();\n    var type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR :\n        (tileState == TileState.LOADED || tileState == TileState.ABORT) ?\n          TileEventType.TILELOADEND : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  };\n\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  };\n\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string=} key Optional new tile key for the source.\n   * @api\n   */\n  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  };\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  UrlTile.prototype.setUrl = function setUrl (url) {\n    var urls = this.urls = expandUrl(url);\n    this.setUrls(urls);\n  };\n\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  UrlTile.prototype.setUrls = function setUrls (urls) {\n    this.urls = urls;\n    var key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  UrlTile.prototype.useTile = function useTile (z, x, y) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n\n  return UrlTile;\n}(TileSource));\n\n\nexport default UrlTile;\n\n//# sourceMappingURL=UrlTile.js.map","/**\n * @module ol/source/TileImage\n */\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\nimport {getUid} from '../util.js';\nimport ImageTile from '../ImageTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {listen} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport UrlTile from './UrlTile.js';\nimport {getKey, getKeyZXY} from '../tilecoord.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} projection Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n */\n\n\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar TileImage = /*@__PURE__*/(function (UrlTile) {\n  function TileImage(options) {\n\n    UrlTile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction ?\n        options.tileLoadFunction : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass = options.tileClass !== undefined ?\n      options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n    this.tileCacheForProjection = {};\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  if ( UrlTile ) TileImage.__proto__ = UrlTile;\n  TileImage.prototype = Object.create( UrlTile && UrlTile.prototype );\n  TileImage.prototype.constructor = TileImage;\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.canExpireCache = function canExpireCache () {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.canExpireCache.call(this);\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (var key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      UrlTile.prototype.expireCache.call(this, projection, usedTiles);\n      return;\n    }\n    var usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n    for (var id in this.tileCacheForProjection) {\n      var tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.getGutterForProjection = function getGutterForProjection (projection) {\n    if (ENABLE_RASTER_REPROJECTION &&\n        this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  };\n\n  /**\n   * @return {number} Gutter.\n   */\n  TileImage.prototype.getGutter = function getGutter () {\n    return 0;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.getOpaque = function getOpaque (projection) {\n    if (ENABLE_RASTER_REPROJECTION &&\n        this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return false;\n    } else {\n      return UrlTile.prototype.getOpaque.call(this, projection);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.getTileGridForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = getTileGridForProjection(projection);\n      }\n      return (\n        /** @type {!import(\"../tilegrid/TileGrid.js\").default} */ (this.tileGridForProjection[projKey])\n      );\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection(); if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  };\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @private\n   */\n  TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord, projection);\n    var tileUrl = urlTileCoord ?\n      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\n    var tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions);\n    tile.key = key;\n    listen(tile, EventType.CHANGE,\n      this.handleTileChange, this);\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {\n    var sourceProjection = /** @type {!import(\"../proj/Projection.js\").default} */ (this.getProjection());\n    if (!ENABLE_RASTER_REPROJECTION ||\n        !sourceProjection || !projection || equivalent(sourceProjection, projection)) {\n      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n    } else {\n      var cache = this.getTileCacheForProjection(projection);\n      var tileCoord = [z, x, y];\n      var tile;\n      var tileCoordKey = getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = /** @type {!import(\"../Tile.js\").default} */ (cache.get(tileCoordKey));\n      }\n      var key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        var targetTileGrid = this.getTileGridForProjection(projection);\n        var wrappedTileCoord =\n            this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var newTile = new ReprojTile(\n          sourceProjection, sourceTileGrid,\n          projection, targetTileGrid,\n          tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),\n          this.getGutter(),\n          function(z, x, y, pixelRatio) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n          }.bind(this), this.reprojectionErrorThreshold_,\n          this.renderReprojectionEdges_);\n        newTile.key = key;\n\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  };\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @protected\n   */\n  TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {\n    var tile = null;\n    var tileCoordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        var interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n\n        //make the new tile the head of the list,\n        if (interimTile.getState() == TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  };\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {\n    if (!ENABLE_RASTER_REPROJECTION ||\n        this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (var id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  };\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      var proj = getProjection(projection);\n      if (proj) {\n        var projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  };\n\n  return TileImage;\n}(UrlTile));\n\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;\n}\n\nexport default TileImage;\n\n//# sourceMappingURL=TileImage.js.map","/**\n * @module ol/source/XYZ\n */\n\nimport TileImage from './TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=18] Optional max zoom level.\n * @property {number} [minZoom=0] Optional min zoom level.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if url or urls are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case,\n * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`\n * such as:\n *\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *        coordinate[1] + '/' + coordinate[2] + '.png';\n *    }\n *\n * @api\n */\nvar XYZ = /*@__PURE__*/(function (TileImage) {\n  function XYZ(opt_options) {\n    var options = opt_options || {};\n    var projection = options.projection !== undefined ?\n      options.projection : 'EPSG:3857';\n\n    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :\n      createXYZ({\n        extent: extentFromProjection(projection),\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n\n    TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n\n  }\n\n  if ( TileImage ) XYZ.__proto__ = TileImage;\n  XYZ.prototype = Object.create( TileImage && TileImage.prototype );\n  XYZ.prototype.constructor = XYZ;\n\n  return XYZ;\n}(TileImage));\n\nexport default XYZ;\n\n//# sourceMappingURL=XYZ.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport TileRange, {createOrUpdate as createOrUpdateTileRange} from '../TileRange.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {toSize} from '../size.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\n\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Sizes.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = function TileGrid(options) {\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n  /**\n   * @private\n   * @type {!Array<number>}\n   */\n  this.resolutions_ = options.resolutions;\n  assert(isSorted(this.resolutions_, function(a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n\n\n  // check if we've got a consistent zoom factor and origin\n  var zoomFactor;\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.zoomFactor_ = zoomFactor;\n\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.maxZoom = this.resolutions_.length - 1;\n\n  /**\n   * @private\n   * @type {import(\"../coordinate.js\").Coordinate}\n   */\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n\n  /**\n   * @private\n   * @type {Array<import(\"../coordinate.js\").Coordinate>}\n   */\n  this.origins_ = null;\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n    assert(this.origins_.length == this.resolutions_.length,\n      20); // Number of `origins` and `resolutions` must be equal\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined &&\n      !this.origin_ && !this.origins_) {\n    this.origin_ = getTopLeft(extent);\n  }\n\n  assert(\n    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n    18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array<number|import(\"../size.js\").Size>}\n   */\n  this.tileSizes_ = null;\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n    assert(this.tileSizes_.length == this.resolutions_.length,\n      19); // Number of `tileSizes` and `resolutions` must be equal\n  }\n\n  /**\n   * @private\n   * @type {number|import(\"../size.js\").Size}\n   */\n  this.tileSize_ = options.tileSize !== undefined ?\n    options.tileSize :\n    !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n  assert(\n    (!this.tileSize_ && this.tileSizes_) ||\n      (this.tileSize_ && !this.tileSizes_),\n    22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {import(\"../extent.js\").Extent}\n   */\n  this.extent_ = extent !== undefined ? extent : null;\n\n\n  /**\n   * @private\n   * @type {Array<import(\"../TileRange.js\").default>}\n   */\n  this.fullTileRanges_ = null;\n\n  /**\n   * @private\n   * @type {import(\"../size.js\").Size}\n   */\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function(size, z) {\n      var tileRange = new TileRange(\n        Math.min(0, size[0]), Math.max(size[0] - 1, -1),\n        Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n\n};\n\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(import(\"../tilecoord.js\").TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\nTileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, import(\"../TileRange.js\").default): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\nTileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n    --z;\n  }\n  return false;\n};\n\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getExtent = function getExtent () {\n  return this.extent_;\n};\n\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\nTileGrid.prototype.getMaxZoom = function getMaxZoom () {\n  return this.maxZoom;\n};\n\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\nTileGrid.prototype.getMinZoom = function getMinZoom () {\n  return this.minZoom;\n};\n\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {import(\"../coordinate.js\").Coordinate} Origin.\n * @api\n */\nTileGrid.prototype.getOrigin = function getOrigin (z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\nTileGrid.prototype.getResolution = function getResolution (z) {\n  return this.resolutions_[z];\n};\n\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array<number>} Resolutions.\n * @api\n */\nTileGrid.prototype.getResolutions = function getResolutions () {\n  return this.resolutions_;\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(\n      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n  return null;\n};\n\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {\n  var tileCoord = tmpTileCoord;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n */\nTileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  return [\n    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\n  ];\n};\n\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n * @api\n */\nTileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get the tile coordinate for the given map coordinate and resolution.This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(\n    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.This method is for integer zoom\n * levels.The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(\n    coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\nTileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n * @param {number} z Z.\n * @return {number|import(\"../size.js\").Size} Tile size.\n * @api\n */\nTileGrid.prototype.getTileSize = function getTileSize (z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n\n/**\n * @param {number} z Zoom level.\n * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n */\nTileGrid.prototype.getFullTileRange = function getFullTileRange (z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *   If 1, the nearest lower resolution will be used. If -1, the nearest\n *   higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\nTileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {\n  var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n  return clamp(z, this.minZoom, this.maxZoom);\n};\n\n/**\n * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n * @private\n */\nTileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n  this.fullTileRanges_ = fullTileRanges;\n};\n\n\nexport default TileGrid;\n\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/source/OSM\n */\n\nimport XYZ from './XYZ.js';\n\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport var ATTRIBUTION = '&#169; ' +\n      '<a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> ' +\n      'contributors.';\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nvar OSM = /*@__PURE__*/(function (XYZ) {\n  function OSM(opt_options) {\n\n    var options = opt_options || {};\n\n    var attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    var crossOrigin = options.crossOrigin !== undefined ?\n      options.crossOrigin : 'anonymous';\n\n    var url = options.url !== undefined ?\n      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    XYZ.call(this, {\n      attributions: attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      url: url,\n      wrapX: options.wrapX,\n      attributionsCollapsible: false\n    });\n\n  }\n\n  if ( XYZ ) OSM.__proto__ = XYZ;\n  OSM.prototype = Object.create( XYZ && XYZ.prototype );\n  OSM.prototype.constructor = OSM;\n\n  return OSM;\n}(XYZ));\n\nexport default OSM;\n\n//# sourceMappingURL=OSM.js.map","/**\n * @module ol/source/Source\n */\nimport {abstract} from '../util.js';\nimport BaseObject from '../Object.js';\nimport {get as getProjection} from '../proj.js';\nimport SourceState from './State.js';\n\n\n/**\n * A function that returns a string or an array of strings representing source\n * attributions.\n *\n * @typedef {function(import(\"../PluggableMap.js\").FrameState): (string|Array<string>)} Attribution\n */\n\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * * a simple string (e.g. `'© Acme Inc.'`)\n * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\n * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} projection\n * @property {SourceState} [state='ready']\n * @property {boolean} [wrapX=false]\n */\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nvar Source = /*@__PURE__*/(function (BaseObject) {\n  function Source(options) {\n\n    BaseObject.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = getProjection(options.projection);\n\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n    this.attributions_ = adaptAttributions(options.attributions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ?\n      options.attributionsCollapsible : true;\n\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map's tile queue never set this to `true`.\n     * @type {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * @private\n     * @type {SourceState}\n     */\n    this.state_ = options.state !== undefined ?\n      options.state : SourceState.READY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n\n  }\n\n  if ( BaseObject ) Source.__proto__ = BaseObject;\n  Source.prototype = Object.create( BaseObject && BaseObject.prototype );\n  Source.prototype.constructor = Source;\n\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   */\n  Source.prototype.getAttributions = function getAttributions () {\n    return this.attributions_;\n  };\n\n  /**\n   * @return {boolean} Aattributions are collapsible.\n   */\n  Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible () {\n    return this.attributionsCollapsible_;\n  };\n\n  /**\n   * Get the projection of the source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  Source.prototype.getProjection = function getProjection () {\n    return this.projection_;\n  };\n\n  /**\n   * @abstract\n   * @return {Array<number>|undefined} Resolutions.\n   */\n  Source.prototype.getResolutions = function getResolutions () {\n    return abstract();\n  };\n\n  /**\n   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\n   * @return {SourceState} State.\n   * @api\n   */\n  Source.prototype.getState = function getState () {\n    return this.state_;\n  };\n\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  Source.prototype.getWrapX = function getWrapX () {\n    return this.wrapX_;\n  };\n\n  /**\n   * Refreshes the source and finally dispatches a 'change' event.\n   * @api\n   */\n  Source.prototype.refresh = function refresh () {\n    this.changed();\n  };\n\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,\n   *     or `undefined`.\n   * @api\n   */\n  Source.prototype.setAttributions = function setAttributions (attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  };\n\n  /**\n   * Set the state of the source.\n   * @param {SourceState} state State.\n   * @protected\n   */\n  Source.prototype.setState = function setState (state) {\n    this.state_ = state;\n    this.changed();\n  };\n\n  return Source;\n}(BaseObject));\n\n\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {?Attribution} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (Array.isArray(attributionLike)) {\n    return function(frameState) {\n      return attributionLike;\n    };\n  }\n\n  if (typeof attributionLike === 'function') {\n    return attributionLike;\n  }\n\n  return function(frameState) {\n    return [attributionLike];\n  };\n}\n\n\nexport default Source;\n\n//# sourceMappingURL=Source.js.map"],"sourceRoot":""}